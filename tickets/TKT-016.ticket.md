---
status: resolved
priority: medium
created: 2026-02-02
---
# TKT-016: Add MCP server hosted in Next.js

## Overview
Implement an MCP (Model Context Protocol) server within the Next.js application, enabling AI clients (ChatGPT, Claude, Copilot) to interact with the app.

## Reference Implementation
See `/Users/jim/Projects/tisket/web/src/app/api/mcp/route.ts` (1,711 lines)

## Architecture

**Transport:** HTTP via Next.js API routes
**Protocol:** JSON-RPC 2.0
**Version:** `2024-11-05`
**Endpoint:** `/api/mcp`

## Core Components

### 1. MCP Route Handler (`src/app/api/mcp/route.ts`)

```typescript
import { NextRequest, NextResponse } from "next/server";
import { validateAccessToken } from "@/lib/auth";

interface McpRequest {
  jsonrpc: "2.0";
  id: string | number;
  method: string;
  params?: Record<string, unknown>;
}

// Validate bearer token for API access
async function validateMcpRequest(request: Request) {
  const authHeader = request.headers.get("authorization");
  if (!authHeader?.startsWith("Bearer ")) {
    return { user: null, error: "No bearer token provided" };
  }
  return validateAccessToken(authHeader.slice(7));
}

export async function POST(request: NextRequest) {
  const authResult = await validateMcpRequest(request);

  if (!authResult.user) {
    return NextResponse.json(
      { error: authResult.error || "Unauthorized" },
      {
        status: 401,
        headers: { "WWW-Authenticate": getWWWAuthenticateHeader(request) },
      }
    );
  }

  const sessionId = request.headers.get("x-session-id") || `user-${authResult.user.id}`;
  const session = await getOrCreateSession(sessionId, authResult.user);
  
  const body: McpRequest = await request.json();
  const response = await handleMcpRequest(body, session);

  return NextResponse.json(response, {
    headers: { "x-session-id": session.id },
  });
}

export async function GET() {
  return NextResponse.json({
    name: "tisket-hris-mcp",
    version: "0.1.0",
    description: "HRIS MCP Server",
    tools: TOOLS.length,
  });
}
```

### 2. MCP Request Handler

```typescript
async function handleMcpRequest(request: McpRequest, session: Session) {
  const { method, params, id } = request;

  switch (method) {
    case "initialize":
      return {
        jsonrpc: "2.0",
        id,
        result: {
          protocolVersion: "2024-11-05",
          serverInfo: { name: "tisket-hris-mcp", version: "0.1.0" },
          capabilities: { tools: {} },
        },
      };

    case "tools/list":
      return {
        jsonrpc: "2.0",
        id,
        result: { tools: TOOLS },
      };

    case "tools/call":
      const { name, arguments: args } = params as { name: string; arguments: Record<string, unknown> };
      const result = await executeToolHandler(name, args, session);
      return {
        jsonrpc: "2.0",
        id,
        result,
      };

    default:
      return {
        jsonrpc: "2.0",
        id,
        error: { code: -32601, message: `Method not found: ${method}` },
      };
  }
}
```

### 3. Session Management

```typescript
interface Session {
  id: string;
  user: TisketUser;
  context: Record<string, unknown>;  // App-specific context
  lastAccess: number;
  initialized: boolean;
}

const sessions = new Map<string, Session>();
const SESSION_TTL = 60 * 60 * 1000; // 1 hour

async function getOrCreateSession(sessionId: string, user: TisketUser): Promise<Session> {
  let session = sessions.get(sessionId);
  
  if (session) {
    session.lastAccess = Date.now();
    return session;
  }

  session = {
    id: sessionId,
    user,
    context: {},
    lastAccess: Date.now(),
    initialized: false,
  };
  
  sessions.set(sessionId, session);
  return session;
}
```

### 4. Tool Definitions

```typescript
const TOOLS = [
  {
    name: "list_employees",
    description: "List employees with optional filters",
    inputSchema: {
      type: "object",
      properties: {
        status: { type: "string", enum: ["active", "inactive", "all"] },
        department: { type: "string" },
        limit: { type: "number", default: 50 },
      },
    },
  },
  {
    name: "get_employee",
    description: "Get employee details by ID",
    inputSchema: {
      type: "object",
      properties: {
        employeeId: { type: "string" },
      },
      required: ["employeeId"],
    },
  },
  // Add more tools as needed...
];
```

### 5. Tool Handler Pattern

```typescript
interface ToolResult {
  content: Array<{ type: "text"; text: string }>;
  isError?: boolean;
}

const toolHandlers: Record<string, (args: Record<string, unknown>, session: Session) => Promise<ToolResult>> = {
  list_employees: async (args, session) => {
    // Implementation using tRPC or direct DB access
    const employees = await getEmployees(args);
    return {
      content: [{ type: "text", text: JSON.stringify(employees, null, 2) }],
    };
  },
  
  get_employee: async (args, session) => {
    const { employeeId } = args as { employeeId: string };
    const employee = await getEmployee(employeeId);
    if (!employee) {
      return {
        content: [{ type: "text", text: `Employee ${employeeId} not found` }],
        isError: true,
      };
    }
    return {
      content: [{ type: "text", text: JSON.stringify(employee, null, 2) }],
    };
  },
};

async function executeToolHandler(name: string, args: Record<string, unknown>, session: Session): Promise<ToolResult> {
  const handler = toolHandlers[name];
  if (!handler) {
    return {
      content: [{ type: "text", text: `Unknown tool: ${name}` }],
      isError: true,
    };
  }
  return handler(args, session);
}
```

### 6. WWW-Authenticate Header (OAuth Discovery)

```typescript
function getWWWAuthenticateHeader(request: Request): string {
  const url = new URL(request.url);
  const baseUrl = `${url.protocol}//${url.host}`;
  
  return [
    'Bearer error="unauthorized"',
    'error_description="Authorization needed"',
    `resource_metadata="${baseUrl}/.well-known/oauth-protected-resource"`,
  ].join(", ");
}
```

## Middleware Configuration

Add `/api/mcp` to unauthenticated paths (uses Bearer tokens instead):
```typescript
middlewareAuth: {
  enabled: true,
  unauthenticatedPaths: [
    "/",
    "/.well-known/:path*",
    "/api/mcp",  // Auth handled at route level
  ],
},
```

## Suggested Tools for HRIS

- `list_employees` - List/search employees
- `get_employee` - Get employee details
- `list_payruns` - List payroll runs
- `get_payrun` - Get payrun details
- `list_leave_requests` - List leave requests
- `approve_leave` - Approve leave request
- `get_payslip` - Get employee payslip
- `run_report` - Execute HRIS reports

## Dependencies

```json
{
  "jose": "^5.x",  // JWT verification (already used by WorkOS)
}
```

Optional for enhanced features:
- `@upstash/redis` - Session persistence across instances
- `@e2b/code-interpreter` - Sandboxed code execution for reports

---

**James Holland** Â· *2026-02-02*

> Added MCP server at /api/mcp with OAuth discovery endpoints (/.well-known/oauth-authorization-server, /.well-known/oauth-protected-resource). Implemented payroll tools: list_employees, get_employee, list_paygroups, list_payruns, get_payrun. Uses WorkOS JWT validation for auth.
