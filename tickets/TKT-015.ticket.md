---
status: open
priority: medium
created: 2026-02-02
---
# TKT-015: Implement WorkOS authentication in Next.js app

## Overview
Implement WorkOS AuthKit authentication following the pattern established in `/Users/jim/Projects/tisket/web`.

## Reference Implementation

### Package
```json
"@workos-inc/authkit-nextjs": "^2.13.0"
```

### Environment Variables Required
```
WORKOS_CLIENT_ID=client_...
WORKOS_API_KEY=sk_test_...
WORKOS_COOKIE_PASSWORD="..." (32+ chars for encryption)
NEXT_PUBLIC_WORKOS_AUTHKIT_DOMAIN=your-app.authkit.app
WORKOS_REDIRECT_URI=http://localhost:3000/callback
```

### File Structure to Create

#### 1. Middleware (`src/middleware.ts`)
```typescript
import { authkitMiddleware } from "@workos-inc/authkit-nextjs";

export default authkitMiddleware({
  redirectUri: process.env.WORKOS_REDIRECT_URI,
  middlewareAuth: {
    enabled: true,
    unauthenticatedPaths: [
      "/",
      "/.well-known/:path*",
      "/api/mcp",
    ],
  },
});

export const config = {
  matcher: [
    "/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)",
  ],
};
```

#### 2. Login Route (`src/app/login/route.ts`)
```typescript
import { getSignInUrl } from "@workos-inc/authkit-nextjs";
import { redirect } from "next/navigation";

export const GET = async () => {
  const signInUrl = await getSignInUrl();
  return redirect(signInUrl);
};
```

#### 3. Callback Route (`src/app/callback/route.ts`)
```typescript
import { handleAuth } from "@workos-inc/authkit-nextjs";

export const GET = handleAuth({ returnPathname: "/workspace" });
```

#### 4. Sign-out Route (`src/app/signout/route.ts`)
```typescript
import { signOut } from "@workos-inc/authkit-nextjs";

export async function GET() {
  return signOut();
}

export async function POST() {
  return signOut();
}
```

#### 5. Auth Library (`src/lib/auth.ts`)
```typescript
import { withAuth, getSignInUrl, getSignUpUrl, signOut } from "@workos-inc/authkit-nextjs";
import { createRemoteJWKSet, jwtVerify } from "jose";

export interface TisketUser {
  id: string;
  email: string;
  name: string;
  avatarUrl?: string;
  organizationId?: string;
}

const AUTHKIT_DOMAIN = process.env.NEXT_PUBLIC_WORKOS_AUTHKIT_DOMAIN;

let jwksClient: ReturnType<typeof createRemoteJWKSet> | null = null;

function getJWKS() {
  if (!jwksClient && AUTHKIT_DOMAIN) {
    jwksClient = createRemoteJWKSet(
      new URL(`https://${AUTHKIT_DOMAIN}/oauth2/jwks`)
    );
  }
  return jwksClient;
}

export async function getSessionUser(): Promise<TisketUser | null> {
  try {
    const { user } = await withAuth();
    if (!user) return null;

    return {
      id: user.id,
      email: user.email || "",
      name: [user.firstName, user.lastName].filter(Boolean).join(" ") || user.email || user.id,
      avatarUrl: user.profilePictureUrl || undefined,
    };
  } catch {
    return null;
  }
}

export async function validateAccessToken(token: string): Promise<{ user: TisketUser | null; error?: string }> {
  const jwksClient = getJWKS();
  
  if (!jwksClient || !AUTHKIT_DOMAIN) {
    return { user: null, error: "WORKOS_AUTHKIT_DOMAIN not configured" };
  }

  try {
    const { payload } = await jwtVerify(token, jwksClient, {
      issuer: `https://${AUTHKIT_DOMAIN}`,
    });

    const userId = payload.sub;
    if (!userId) {
      return { user: null, error: "Invalid token: no subject" };
    }

    return {
      user: {
        id: userId,
        email: (payload.email as string) || "",
        name: (payload.name as string) || (payload.email as string) || userId,
        organizationId: payload.org_id as string | undefined,
      },
    };
  } catch (error) {
    return { user: null, error: "Invalid or expired token" };
  }
}

export { withAuth, getSignInUrl, getSignUpUrl, signOut };
```

#### 6. OAuth Metadata Endpoints (for MCP clients)

**`.well-known/oauth-authorization-server/route.ts`:**
```typescript
import { NextResponse } from "next/server";

const AUTHKIT_DOMAIN = process.env.NEXT_PUBLIC_WORKOS_AUTHKIT_DOMAIN;

export async function GET() {
  if (!AUTHKIT_DOMAIN) {
    return NextResponse.json({ error: "WORKOS_AUTHKIT_DOMAIN not configured" }, { status: 500 });
  }

  const response = await fetch(`https://${AUTHKIT_DOMAIN}/.well-known/oauth-authorization-server`);
  if (!response.ok) {
    return NextResponse.json({ error: "Failed to fetch authorization server metadata" }, { status: 502 });
  }

  return NextResponse.json(await response.json());
}
```

**`.well-known/oauth-protected-resource/route.ts`:**
```typescript
import { NextRequest, NextResponse } from "next/server";

const AUTHKIT_DOMAIN = process.env.NEXT_PUBLIC_WORKOS_AUTHKIT_DOMAIN;
const APP_URL = process.env.NEXT_PUBLIC_APP_URL;

export async function GET(request: NextRequest) {
  const baseUrl = APP_URL || `${request.nextUrl.protocol}//${request.nextUrl.host}`;

  if (!AUTHKIT_DOMAIN) {
    return NextResponse.json({ error: "WORKOS_AUTHKIT_DOMAIN not configured" }, { status: 500 });
  }

  return NextResponse.json({
    resource: baseUrl,
    authorization_servers: [`https://${AUTHKIT_DOMAIN}`],
    bearer_methods_supported: ["header"],
  });
}
```

### Authentication Flow
1. User navigates to protected route
2. Middleware intercepts, redirects to `/login` if no session
3. `/login` redirects to WorkOS AuthKit
4. User authenticates at WorkOS
5. WorkOS redirects to `/callback` with auth code
6. `handleAuth()` validates and creates encrypted session cookie
7. User redirected to protected route

### Protected Layout Pattern
```typescript
export default async function ProtectedLayout({ children }) {
  const sessionUser = await getSessionUser();

  if (!sessionUser) {
    const signInUrl = await getSignInUrl();
    redirect(signInUrl);
  }

  // ... render layout with user context
}
```

---

**James Holland** Â· *2026-02-02*

> Detailed implementation guide complete. This is a large migration from Clerk affecting 10+ files. Should be planned as a dedicated effort rather than part of general refactoring.
